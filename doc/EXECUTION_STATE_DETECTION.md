# Execution State Detection — Design Notes

## Problem

Online monitoring needs to display which nodes are currently "active" (being executed) on the PLC. ADS provides variable read/write and PLC state queries, but **no direct way to query whether a specific code block is executing**. We must infer execution state ourselves.

## Execution Model

Every PLC program has a **Task** that cyclically calls a **PRG** (entry point). From there, execution flows deterministically through the call chain:

```
Task (cyclic) → PRG → FB calls → Method calls → ...
```

At each branching point (IF, CASE, FOR), the taken branch depends on runtime variable values — which we *can* read via ADS.

## Two Categories

### 1. Deterministic call chain (PRG → FB → Method)

The PRG entry is always active while the Task runs. From there, the execution graph is fully known from the flow document. At each conditional branch, we can read the condition variable via ADS and determine which path is active.

**Approach: Graph-based condition propagation**

1. Start from the PRG entry node — always active when PLC is in `Run` state
2. Walk the exec chain (ENO, TRUE, DO branches)
3. At each conditional node (IF, CASE), read the runtime condition value from ADS
4. Propagate "active" only along the taken branch
5. When a method call node is active → the corresponding method body entry is active
6. Recurse into the method body with the same logic

**Example:**
```
Entry(MAIN) → Timer → Counter → Comparison → IF(COND=true)
                                                 ├─ TRUE → MethodCall(CleanupCycle) → active
                                                 └─ FALSE → ... → idle
```

If `IF.COND` reads `TRUE` from ADS → the TRUE branch and everything downstream (including CleanupCycle method body) is marked active.

**Advantages:**
- No extra PLC code or variables needed
- Uses only existing ADS variable reads (already available for value display)
- Computation happens entirely on the monitor server / frontend
- Follows the actual execution semantics accurately

**Limitations:**
- Only works for call chains originating from the flow graph we control
- Timing: we read condition values at poll intervals, not at exact PLC scan boundaries — but this is acceptable for visualization (same polling we use for value display)

### 2. Non-deterministic access (Property GET/SET)

Property accessors are fundamentally different:

- A **GET** accessor runs whenever *any* external code reads the property (`fbInstance.PropertyName`)
- A **SET** accessor runs whenever *any* external code writes to it
- The caller may be outside our flow graph (another POU, library code, HMI, etc.)
- The same property can be accessed from multiple places, with different cycle times
- There is no single "call node" in our graph that gates the accessor execution

The graph-based approach cannot determine whether a property accessor is running, because the caller is not necessarily part of the flow we're monitoring.

**Approach: Generated execution counter**

The code generator injects a hidden counter variable into each property accessor body:

```iecst
// Auto-generated by FlowForge — do not modify
VAR
    _ff_execCount : UDINT;  // Increments each call
END_VAR

// First line of GET/SET body:
_ff_execCount := _ff_execCount + 1;
```

The monitor polls `_ff_execCount` at regular intervals:
- If `current - previous > 0` → accessor is being called → mark as **active**
- If unchanged → no calls since last poll → mark as **idle**

**Advantages:**
- Works regardless of who calls the accessor
- Accurate: directly measures actual execution
- Minimal PLC overhead: single UDINT increment per call

**Considerations:**
- Requires the code generator to inject the counter variable and increment statement
- UDINT overflow: wraps at ~4.29 billion — not a practical concern (at 1ms cycle, wraps after ~49 days; and we only check delta, not absolute value)
- Polling interval determines detection latency (same as variable value display)

## Summary

| Aspect | PRG / FB / Method body | Property GET / SET |
|--------|----------------------|-------------------|
| Call chain | Known from flow graph | Unknown (external callers) |
| Detection method | Graph-based condition propagation | Generated `_ff_execCount` counter |
| Extra PLC code needed | No | Yes (one UDINT + increment per accessor) |
| Accuracy | Condition-value dependent | Direct measurement |
| Computation location | Monitor server / frontend | Monitor reads counter via ADS |

## Implementation Notes

- The graph-based propagation reuses the execution chain walker (`computeExecutionOrder` / `computeExecutionChains`) — extend it to evaluate runtime conditions
- The `_ff_execCount` variable follows the naming convention `_ff_*` to avoid collision with user variables and to allow the monitor to discover them automatically via ADS symbol enumeration
- Both approaches use the same polling interval as variable value display (no additional ADS traffic)
- Edge case: nested FB instances calling the same property — the counter captures all calls regardless of source, which is the desired behavior
